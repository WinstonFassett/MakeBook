"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generate = void 0;
var fs_1 = require("fs");
var path = __importStar(require("path"));
var config_1 = require("./config");
var footer_1 = require("./content/footer");
var context_1 = require("./parser/context");
var parse_1 = require("./parser/parse");
var PROGRAM_NAME = "makepdf";
var DEFAULT_CONFIG = "makepdf.json";
var writeOutputLog = false;
/** Output PDF using `pdfmake` */
function writePdf(content, ctx) {
    if (writeOutputLog)
        console.log("...generating PDF");
    var PdfPrinter = require("pdfmake");
    var fonts = (0, config_1.findFontFiles)(ctx.config.fonts);
    var printer = new PdfPrinter(fonts);
    var pdfDoc = printer.createPdfKitDocument({
        info: ctx.config.output.info,
        pageSize: ctx.config.output.pageSize,
        pageOrientation: ctx.config.output.pageOrientation,
        pageMargins: ctx.config.output.pageMargins,
        defaultStyle: ctx.config.styles.default,
        styles: ctx.config.styles,
        pageBreakBefore: config_1.pageBreakBefore,
        content: content,
        footer: (0, footer_1.getFooterFn)(ctx.config),
    }, {
        tableLayouts: (0, config_1.getTableLayouts)(ctx.config),
    });
    var dirName = path.dirname(ctx.config.output.file);
    if (!(0, fs_1.existsSync)(dirName))
        (0, fs_1.mkdirSync)(dirName, { recursive: true });
    if (writeOutputLog)
        console.log("Writing to " + ctx.config.output.file);
    pdfDoc.pipe((0, fs_1.createWriteStream)(ctx.config.output.file));
    pdfDoc.end();
}
/** Run given function for each configuration entry (if config file is an array) */
function withConfig(configFileName, f) {
    if (!configFileName && (0, fs_1.existsSync)(DEFAULT_CONFIG))
        configFileName = DEFAULT_CONFIG;
    if (!configFileName) {
        // use default config for index.md
        f((0, config_1.getConfig)());
    }
    else if (configFileName.endsWith(".md") || configFileName.endsWith(".txt")) {
        // use automatic configuration for a single file
        f((0, config_1.getConfig)({
            input: { entry: configFileName },
            output: { file: configFileName.replace(/\.\w+$/, ".pdf") },
        }));
    }
    else {
        // read config from file
        if (!(0, fs_1.existsSync)(configFileName)) {
            console.log("Configuration file not found: " + configFileName);
            process.exit(1);
        }
        var overrides = JSON.parse((0, fs_1.readFileSync)(configFileName).toString());
        if (!Array.isArray(overrides))
            overrides = [overrides];
        overrides
            .map(function (o) { return (0, config_1.getConfig)(o); })
            .filter(function (c) { return !c.skip; })
            .forEach(f);
    }
}
/** Generate a PDF document using given configuration */
function generate(config) {
    var context = new context_1.OutputContext(config);
    var content;
    try {
        var fileName = config.input.entry;
        if (config.input.baseDir) {
            fileName = path.resolve(config.input.baseDir, fileName);
        }
        content = (0, parse_1.parseMarkdownFile)(fileName, context);
        context.updateRefs();
        if (config.output.debug) {
            (0, fs_1.writeFileSync)("debug.json", JSON.stringify(content, undefined, "  "));
        }
    }
    catch (err) {
        if (err.code === "PARSE_ERROR") {
            console.error("*** Parse error (".concat(err.fileName, ":").concat(err.line, ")\n").concat(err.message));
        }
        else {
            console.error(err);
        }
        return process.exit(1);
    }
    writePdf(content, context);
}
exports.generate = generate;
/** CLI main function */
/*
function main() {
    var arg = process.argv[2];
    if (arg === "--help" || arg === "-h") {
        console.log("Usage: " + PROGRAM_NAME + " [configurationfile]");
        process.exit(0);
    }
    withConfig(arg, function (config) {
        // make paths relative to config file
        var argBase = arg && path.resolve(path.dirname(arg));
        if (config.output.file && argBase) {
            config.output.file = path.resolve(argBase, config.output.file);
        }
        if (config.input.baseDir && argBase) {
            config.input.baseDir = path.resolve(argBase, config.input.baseDir);
        }
        if (!config.input.baseDir)
            config.input.baseDir = argBase;
        // set/warn about output info fields
        if (!config.output.info.creator)
            config.output.info.creator = PROGRAM_NAME;
        if (!config.output.info.producer)
            config.output.info.producer = PROGRAM_NAME;
        if (!config.output.info.author) {
            console.log("Warning: Missing author field in config (output.info.author)");
        }
        if (!config.output.info.title) {
            console.log("Warning: Missing title field in config (output.info.title)");
        }
        if (!config.output.info.subject) {
            console.log("Warning: Missing subject field in config (output.info.subject)");
        }
        // generate the PDF for this config
        writeOutputLog = true;
        generate(config);
    });
}
main();
*/