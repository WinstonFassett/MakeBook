"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.flattenText = exports.asTextNode = exports.parseInline = void 0;
/** Character-based parse context */
var InlineParseContext = /** @class */ (function () {
    function InlineParseContext(s) {
        this._behind = "";
        this._ahead = s;
    }
    /** Returns the next character */
    InlineParseContext.prototype.peek = function () {
        return this._ahead[0];
    };
    /** Removes n characters from the input string */
    InlineParseContext.prototype.shift = function (n) {
        var result = this._ahead.slice(0, n);
        this._behind += result;
        this._ahead = this._ahead.slice(n);
        return result;
    };
    /** Matches against the remaining input string */
    InlineParseContext.prototype.match = function (re) {
        return this._ahead.match(re);
    };
    /** Matches against the already-parsed part of the input string */
    InlineParseContext.prototype.matchBehind = function (re) {
        return this._behind.match(re);
    };
    /** Runs given function with a clone of this context; if the function returns a truethy value, the cloned context is copied back */
    InlineParseContext.prototype.cont = function (f) {
        var next = new InlineParseContext(this._ahead);
        next._behind = this._behind;
        var b = f(next);
        if (b) {
            this._ahead = next._ahead;
            this._behind = next._behind;
        }
        return b;
    };
    return InlineParseContext;
}());
/** Return text as an array of content blocks or strings */
function parseInline(text, outer, props) {
    /** Parse inline literal (code) text */
    function parseCode(ctx) {
        var match = ctx.match(/^\`([^`]*)\`/);
        if (match) {
            ctx.shift(match[0].length);
            return { text: match[1], style: "code" };
        }
    }
    /** Parse text within paired symbols (e.g. **) */
    function parsePaired(ctx, expect, props) {
        var match = ctx.match(expect);
        if (match) {
            var result = ctx.cont(function (next) {
                next.shift(match[0].length); // start
                return parseUntil(next, expect, props);
            });
            if (result)
                ctx.shift(match[0].length); // end
            return result && asTextNode(result);
        }
    }
    /** Parse autonumbering pattern */
    function parseAutoNum(ctx, props) {
        var match = ctx.match(/^\\\\((?:\([^\s\)\.]*\)\.|\[[^\s\]\.]*\]\.)+)(?:\{\#([^\s\}]+)\})?/);
        if (match) {
            ctx.shift(match[0].length);
            var text_1 = outer.output.autoNumber(match[1]);
            var result = __assign(__assign({}, props), { text: text_1, style: "autonum" });
            if (match[2]) {
                result.id = match[2];
                outer.output.addRefId(result.id, text_1.trim(), 0);
            }
            return result;
        }
    }
    /** Parse a link */
    function parseLink(ctx, props) {
        var match = ctx.match(/^\[[^\]]*\]\([^\)]+\)/);
        if (match) {
            return ctx.cont(function (next) {
                next.shift(1); // [
                var text = parseUntil(next, /^\]/, props);
                if (!text)
                    return;
                next.shift(1); // ]
                var urlMatch = next.match(/\(([^\)]+)\)/);
                if (!urlMatch)
                    return;
                next.shift(urlMatch[0].length);
                var url = urlMatch[1].trim();
                if (url[0] === "#") {
                    // parse internal link
                    var id = url.slice(1);
                    if (!text.length) {
                        return outer.output.addRefToUpdate(id, {
                            linkToDestination: id,
                            text: "",
                            style: "doclink",
                        });
                    }
                    return asTextNode(text, { linkToDestination: id, style: "doclink" });
                }
                return asTextNode(text, { link: url, style: "link" });
            });
        }
    }
    /** Parse inline tag */
    function parseTag(ctx, props) {
        var match = ctx.match(/^\\\\(\w+)/);
        if (match) {
            var tag_1 = match[1].toLowerCase();
            if (tag_1 === "blank") {
                ctx.shift(7);
                return { text: "" };
            }
            if (tag_1 === "newline") {
                ctx.shift(9);
                return "\n";
            }
            if (tag_1 === "v" || tag_1 === "verb" || tag_1 === "verbatim") {
                ctx.shift(tag_1.length + 2);
                var text_2 = "";
                var stop_1 = ctx.shift(1);
                var c = void 0;
                while ((c = ctx.shift(1)) !== stop_1) {
                    text_2 += c;
                }
                return props ? __assign(__assign({}, props), { text: text_2 }) : text_2;
            }
            var insertion = ctx.match(/^\\\\insert\s*\(([^\s\)]+)\)/);
            if (insertion) {
                // replace 'insert' in the middle of a line
                // (start of line is handled in parse.ts)
                ctx.shift(insertion[0].length);
                var name_1 = insertion[1];
                return outer.getDefinition(name_1);
            }
            var result = ctx.cont(function (next) {
                var match = ctx.match(/^\\\\\w+(?:\(([^\)]*)\))?\{/);
                if (match) {
                    var params = match[1] || "";
                    props = __assign({}, props);
                    switch (tag_1) {
                        case "bold":
                        case "b":
                            props.bold = true;
                            break;
                        case "italics":
                        case "italic":
                        case "i":
                            props.italics = true;
                            break;
                        case "code":
                        case "kbd":
                            props.style = "code";
                            break;
                        case "underline":
                        case "overline":
                        case "strikethrough":
                        case "linethrough":
                            props.decoration = tag_1;
                            if (tag_1 === "strikethrough" || tag_1 === "linethrough") {
                                props.decoration = "lineThrough";
                            }
                            if (params) {
                                var _a = params.trim().split(/\s+/), style = _a[0], color = _a[1];
                                if (style)
                                    props.decorationStyle = style;
                                if (color)
                                    props.decorationColor = color;
                            }
                            break;
                        case "symbol":
                        case "sym":
                            props.font = "Symbol";
                            props.bold = false;
                            props.italics = false;
                            break;
                        case "color":
                            props.color = params.trim();
                            break;
                        case "style":
                            props = __assign(__assign({}, props), outer.output.getStyleProps(params.trim()));
                            break;
                        default:
                            throw Error("Invalid inline tag: \\\\" + tag_1);
                    }
                    next.shift(match[0].length); // start
                    return parseUntil(next, /^\}/, props);
                }
            });
            if (result)
                ctx.shift(1); // end
            return result && asTextNode(result);
        }
    }
    /** Parse all text until given regexp matches */
    function parseUntil(ctx, expect, props) {
        var result = [];
        var s = "";
        var flush = function () {
            if (s)
                result.push(props ? __assign(__assign({}, props), { text: s }) : s);
            s = "";
        };
        var move = function (r) {
            if (r)
                flush(), result.push(r);
            return r;
        };
        while (!expect || !ctx.match(expect)) {
            // done if there is no more input; check if expecting
            if (!ctx.peek()) {
                if (expect)
                    return;
                break;
            }
            // check for matches ahead of expected match
            if (move(parseCode(ctx)) ||
                move(parsePaired(ctx, /^\*\*/, __assign(__assign({}, props), { bold: true }))) ||
                move(parsePaired(ctx, /^__/, __assign(__assign({}, props), { bold: true }))) ||
                move(parsePaired(ctx, /^\*/, __assign(__assign({}, props), { italics: true }))) ||
                move(parsePaired(ctx, /^_/, __assign(__assign({}, props), { italics: true }))) ||
                move(parsePaired(ctx, /^~~/, __assign(__assign({}, props), { decoration: "lineThrough" }))) ||
                move(parseAutoNum(ctx, props)) ||
                move(parseLink(ctx, props)) ||
                move(parseTag(ctx, props))) {
                continue;
            }
            // check punctuation
            if (ctx.match(/^\\\S/)) {
                var char = ctx.shift(2)[1];
                if (char === "~")
                    char = "\u00A0";
                else if ("\\`*_{}[]()<>#+-.!'\"".indexOf(char) < 0)
                    s += "\\";
                s += char;
            }
            else if (ctx.match(/^\-\-/)) {
                ctx.shift(2);
                s += "—";
            }
            else if (ctx.match(/^\.\.\./)) {
                ctx.shift(3);
                s += "…";
            }
            else if (ctx.peek() === "'") {
                s += ctx.matchBehind(/\S$/) ? "’" : "‘";
                ctx.shift(1);
            }
            else if (ctx.peek() === '"') {
                s += ctx.matchBehind(/\S$/) ? "”" : "“";
                ctx.shift(1);
            }
            else {
                // for anything else, just add plain text and move on
                var match = ctx.match(/^[\p{L}\p{N}]+/u);
                s += ctx.shift(match ? match[0].length : 1);
            }
        }
        flush();
        return result;
    }
    return parseUntil(new InlineParseContext(text), undefined, props) || [text];
}
exports.parseInline = parseInline;
function asTextNode(content, props) {
    var result = { text: "" };
    if (content) {
        if (typeof content === "string")
            result = content;
        else if (content.text)
            result = content;
        else if (content.length === 1)
            result = asTextNode(content[0]);
        else if (content.length)
            result.text = content;
    }
    if (props) {
        if (typeof result === "string")
            result = { text: result };
        if (result.style && props.style)
            result = { text: [result] };
        Object.assign(result, props);
    }
    return result;
}
exports.asTextNode = asTextNode;
/** Return a string of text for given text node */
function flattenText(text, separator) {
    if (typeof text === "string")
        return text.replace(/\s+/g, " ");
    if (Array.isArray(text)) {
        return text
            .map(function (a) { return flattenText(a); })
            .join(separator || "")
            .replace(/\s+/g, " ");
    }
    if (text.text)
        return flattenText(text.text);
    return "";
}
exports.flattenText = flattenText;
