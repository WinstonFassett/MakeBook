"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseMarkdownFile = exports.ParseContext = void 0;
var fs_1 = require("fs");
var blocks_1 = require("../content/blocks");
var inline_1 = require("./inline");
var transclude_1 = require("./transclude");
var RE_LINE_NOT_PLAIN_TEXT = /^(\s*\#|\-\s|\*\s|1\.\s|\`\`\`|\-{3,}\s*$|\\\\\{|\\\\include|\\\\image|\\\\img|\\\\toc|\\\\pagebreak)/;
var RE_TABLE_SEPARATOR_LINE = /^\s*(\|\s*)?(\:?\-{3,}\:?\s*\|?\s*)+$/;
/** Parser context definition */
var ParseContext = /** @class */ (function () {
    function ParseContext(fileName, output, defs) {
        this._n = 1;
        this._lines = [];
        this.fileName = fileName;
        this.output = output;
        this._defs = output.mergeDefinitions(defs);
    }
    ParseContext.prototype.append = function (text) {
        var _a;
        (_a = this._lines).push.apply(_a, text.split(/\r\n|\n\r|\r|\n/));
    };
    /** Returns the current line number (starts at 1) */
    ParseContext.prototype.getLineNumber = function () {
        return this._n;
    };
    /** Returns true if currently at given line number */
    ParseContext.prototype.isAt = function (lineNumber) {
        return this.getLineNumber() === lineNumber;
    };
    /** Returns true if more lines are available */
    ParseContext.prototype.hasInput = function () {
        return !!this._lines.length;
    };
    /** Returns the next line */
    ParseContext.prototype.peek = function () {
        this._autoReplace();
        return this._lines[0] || "";
    };
    /** Returns and removes the next line */
    ParseContext.prototype.shift = function () {
        this._n++;
        this._autoReplace();
        return this._lines.shift() || "";
    };
    /** Runs given function and asserts that one or more lines are used */
    ParseContext.prototype.validate = function (f) {
        var n = this.getLineNumber();
        f();
        if (this.isAt(n)) {
            var str = this.peek() || (this.hasInput() ? "<blank line>" : "<end>");
            throw Error("Cannot parse input: " + str);
        }
    };
    /** Returns the meta/custom definition for given property */
    ParseContext.prototype.getDefinition = function (name) {
        if (this._defs[name] == null) {
            throw Error("Definition not found for: " + name);
        }
        return String(this._defs[name]);
    };
    /** Disable input-level replacements (comments, insert tags) */
    ParseContext.prototype.disableReplacements = function () {
        this._noReplace = true;
    };
    /** Re-enable input-level replacements (after calling `disableReplacements` earlier) */
    ParseContext.prototype.enableReplacements = function () {
        this._noReplace = false;
    };
    /** Replace comments and insert tags for the next line in the buffer */
    ParseContext.prototype._autoReplace = function () {
        var _this = this;
        if (!this._lines.length || this._noReplace)
            return;
        var line = this._lines[0]
            .replace(/<!--(.*?)-->/g, "")
            .replace(/^([-*> \t]+)\\\\insert\s*\(([^\s\)]+)\)/gm, function (_m, pre, name) {
            var _a;
            // replace 'insert' at the START of a line (repeat prefix)
            var defLines = _this.getDefinition(name)
                .split(/\n/)
                .map(function (s) { return pre + s; });
            (_a = _this._lines).splice.apply(_a, __spreadArray([1, 0], defLines.slice(1), false));
            return defLines[0];
        });
        this._lines[0] = line;
    };
    return ParseContext;
}());
exports.ParseContext = ParseContext;
function parse(ctx) {
    /** Next set of custom properties as read from the input */
    var _nextProps;
    /** Get the pending set of (block) properties and clear it right away */
    function getPendingProps() {
        var result = _nextProps || {};
        _nextProps = undefined;
        return result;
    }
    /** Add to the pending set of (block) properties */
    function setPendingProps(props) {
        if (!_nextProps)
            _nextProps = {};
        if (typeof props === "string") {
            props.split(/[\s,;]+/).forEach(function (name) {
                if (!name)
                    return;
                Object.assign(_nextProps, ctx.output.getStyleProps(name));
            });
        }
        else {
            Object.assign(_nextProps, props);
        }
    }
    /** Parse line(s) with custom properties for the next block; does NOT return anything */
    function parseCustomProps(indent) {
        var text = "";
        var start = ctx.getLineNumber();
        var lastError;
        while (ctx.hasInput()) {
            var line = ctx.peek();
            var i = line.match(/^\s*/)[0].length;
            if (i < indent && !ctx.isAt(start))
                break;
            var str = line.slice(indent);
            if (!/^\s*\\\\/.test(str))
                break;
            text += (text ? "\n" : "") + str.replace(/^\s*\\\\/, "").trim();
            ctx.shift();
            try {
                var styleMatch = text.match(/\{\s*([-,;\w\s]+)\}/);
                setPendingProps(styleMatch ? styleMatch[1] : JSON.parse(text));
                text = "";
                break;
            }
            catch (err) {
                lastError = err;
            }
        }
        if (text)
            throw lastError || Error("Invalid property JSON: " + text);
    }
    /** Eat current line and return separator block */
    function parseSeparator() {
        ctx.shift();
        return (0, blocks_1.makeSeparator)(ctx.output.config, getPendingProps());
    }
    /** Parse heading (single line) */
    function parseHeading(indent) {
        var text = ctx.shift().slice(indent);
        var level = text.match(/^\#+/)[0].length;
        text = text.replace(/^\#+\s*/, "");
        var id = "heading__" + ctx.output.getHeadingId();
        text = text.replace(/\s*\{\#([^\s\}]+)\}\s*$/, function (_m, id1) {
            id = id1;
            return "";
        });
        var result = (0, inline_1.parseInline)(text, ctx);
        result.forEach(function (r) {
            if (r.style === "autonum")
                r.style = "autonum_h" + level;
        });
        ctx.output.addRefId(id, result, level);
        return (0, inline_1.asTextNode)(result, __assign({ style: "h" + level, headlineLevel: level, id: id }, getPendingProps()));
    }
    /** Parse paragraph text line(s) */
    function parseParagraph(indent) {
        var props = getPendingProps();
        var start = ctx.getLineNumber();
        var p = "";
        while (ctx.hasInput()) {
            var line = ctx.peek();
            var i = ctx.isAt(start) ? indent : line.match(/^\s*/)[0].length;
            if (i < indent || line.length <= i)
                break;
            var text = line.slice(i).replace(/\\$/, "\n");
            if (RE_LINE_NOT_PLAIN_TEXT.test(text))
                break;
            if (RE_TABLE_SEPARATOR_LINE.test(text)) {
                return parseTable(i, p, props);
            }
            p += (p.length ? " " : "") + text;
            ctx.shift();
        }
        return (0, inline_1.asTextNode)((0, inline_1.parseInline)(p, ctx), __assign({ style: "p" }, props));
    }
    /** Parse table; always called from `parseParagraph` which passes the first (heading) line which may have already been read (but not parsed), the next pending line in the buffer context is going to be the 'separator' line */
    function parseTable(indent, firstLine, props) {
        var headerRows = firstLine ? 1 : 0;
        // read separator line and figure out columns
        var widths = [];
        var alignment = [];
        var sep = ctx.shift().split("|");
        sep = sep.map(function (s) { return s.trim(); });
        sep.forEach(function (col, i) {
            if (!col)
                return;
            widths.push("auto");
            if (col[col.length - 1] === ":") {
                var align = col[0] === ":" ? "center" : "right";
                alignment[i] = align;
            }
        });
        // parse heading line and all rows
        var body = [];
        var parseLine = function (text, style) {
            var p = (0, inline_1.parseInline)(text, ctx);
            var cols = [[]];
            p.forEach(function (node) {
                var current = cols[cols.length - 1];
                if (typeof node === "string") {
                    // look for all pipe chars, filter out
                    // first/last columns below if extra
                    var colSplit = node.split(/(?<!\\)\|/).map(function (s) { return s.replace(/\\\|/g, "|"); });
                    if (colSplit.length > 1) {
                        node = colSplit.pop().trimLeft();
                        colSplit.forEach(function (s) {
                            if (!current.length) {
                                current.push(s.trim());
                            }
                            else if (s !== "") {
                                current.push(s.trimRight());
                            }
                            cols.push((current = []));
                        });
                    }
                }
                if (current.length === 1 && current[0] === "") {
                    cols[cols.length - 1] = current = [node];
                }
                else {
                    current.push(node);
                }
            });
            var row = [];
            cols.forEach(function (col, i) {
                if (!sep[i] && col.length <= 1 && !col[0]) {
                    return;
                }
                var cell = (0, inline_1.asTextNode)(col, { style: style });
                if (alignment[i])
                    cell.alignment = alignment[i];
                row.push(cell);
            });
            if (row.length !== widths.length) {
                var rowText = (0, inline_1.flattenText)(row, " | ");
                if (rowText.length > 40)
                    rowText = rowText.slice(0, 37) + "...";
                throw Error("Inconsistent table row length: " + rowText);
            }
            body.push(row);
        };
        if (firstLine)
            parseLine(firstLine, "tableHeader");
        while (true) {
            var line = ctx.peek();
            var i = line.match(/^\s*/)[0].length;
            if (i < indent || line.length <= i)
                break;
            parseLine(ctx.shift().slice(i), "tableCell");
        }
        // return table structure
        if ("widths" in props)
            widths = props.widths;
        return __assign(__assign({ layout: "default", style: "table" }, props), { table: { body: body, widths: widths, headerRows: headerRows } });
    }
    /** Parse list items at given indentation and starting with given RegExp */
    function parseList(indent, re) {
        var _a;
        var isOrdered = /\d/.test(ctx.peek()[indent]);
        var props = getPendingProps();
        var start = ctx.getLineNumber();
        var items = [];
        // keep going until no longer within the same list
        while (ctx.hasInput()) {
            var line = ctx.peek();
            var i = ctx.isAt(start) ? indent : line.match(/^\s*/)[0].length;
            var text = line.slice(i);
            if (!text.length) {
                // skip empty lines between list items
                ctx.shift();
                continue;
            }
            if (i < indent)
                break;
            // find out text indent and parse content
            if (!re.test(text))
                break;
            text = text.replace(re, "");
            var textIndent = line.length - text.length;
            var li = parseAny(textIndent);
            if (li.length === 1) {
                var content = li[0];
                if (typeof content === "string") {
                    items.push({ text: content, style: "li" });
                }
                else if (Array.isArray(content)) {
                    items.push({ stack: content, style: "li" });
                }
                else if (!content.style || content.style === "p") {
                    items.push(__assign(__assign({}, content), { style: "li" }));
                }
                else if (content.ul || content.ol) {
                    items.push(content);
                }
                else {
                    items.push(__assign({ style: "li" }, content));
                }
            }
            else {
                items.push({ stack: li, style: "li" });
            }
        }
        // convert to table if props contain 'table'
        if ("table" in props) {
            return listToTable(items, props);
        }
        // convert to columns if props contain 'columns'
        if ("columns" in props || "columnGap" in props) {
            return listToColumns(items, props);
        }
        // return OL or UL structure
        var type = isOrdered ? "ol" : "ul";
        var style = indent ? type + "_inner" : type;
        return __assign((_a = {}, _a[type] = items, _a.style = style, _a), props);
    }
    /** Converts a nested list structure to a table */
    function listToTable(items, props) {
        var widths = props.widths;
        var layout = props.table;
        if (!(typeof layout === "string"))
            layout = "default";
        var headerRows = "headerRows" in props ? props.headerRows : 1;
        // turn all nested ULs into rows
        var body = items.map(function (r, i) {
            if (!r.ul) {
                r = r.stack && r.stack.filter(function (n) { return n.ul; })[0];
                if (!r || !r.ul)
                    return;
            }
            r.ul.forEach(function (c) {
                if (c.style === "li") {
                    c.style = i >= headerRows ? "tableCell" : "tableHeader";
                }
            });
            return r.ul;
        });
        body = body.filter(function (r) { return !!r; });
        if (!body.length)
            throw Error("Table has no rows");
        return __assign(__assign({ layout: layout, style: "table" }, props), { table: { body: body, widths: widths, headerRows: headerRows } });
    }
    /** Converts a list structure to a group of columns */
    function listToColumns(columns, props) {
        var widths = props.widths;
        if (Array.isArray(widths)) {
            widths.forEach(function (width, i) {
                if (columns[i]) {
                    if (columns[i].stack) {
                        columns[i] = __assign(__assign({}, columns[i]), { width: width });
                    }
                    else {
                        columns[i] = (0, inline_1.asTextNode)(columns[i], { width: width });
                    }
                }
            });
        }
        return __assign(__assign({ style: "block_outer" }, props), { columns: columns });
    }
    /** Parse a pre-formatted block (until next backticks) */
    function parsePre(indent) {
        var firstLine = ctx.shift(); // eat up first backticks
        var ticks = firstLine.match(/^\s*(\`+)/)[1];
        var start = ctx.getLineNumber();
        var stack = [];
        ctx.disableReplacements();
        while (ctx.hasInput()) {
            var line = ctx.peek();
            var i = ctx.isAt(start) ? indent : line.match(/^\s*/)[0].length;
            var str = line.slice(indent);
            if (i < indent && str)
                break;
            ctx.shift();
            if (str.slice(0, ticks.length) === ticks)
                break;
            if (!str)
                str = "\u00A0";
            stack.push((0, inline_1.asTextNode)(str, { style: "code", preserveLeadingSpaces: true }));
        }
        ctx.enableReplacements();
        var props = ctx.output.getStyleProps("pre");
        if (stack.length <= 5)
            props.unbreakable = true;
        return (0, blocks_1.makeBlock)(stack, __assign(__assign({}, props), getPendingProps()));
    }
    /** Parse a (quote) block */
    function parseBlock(indent) {
        var next = new (/** @class */ (function (_super) {
            __extends(class_1, _super);
            function class_1() {
                return _super.call(this, ctx.fileName, ctx.output) || this;
            }
            class_1.prototype.getDefinition = function (name) {
                return ctx.getDefinition(name);
            };
            class_1.prototype.hasInput = function () {
                var next = ctx.peek();
                var i = next.match(/^\s*/)[0].length;
                return i === indent && next[i] === ">";
            };
            class_1.prototype.peek = function () {
                return ctx.peek().replace(/^\s*\>\s?/, "");
            };
            class_1.prototype.shift = function () {
                return ctx.shift().replace(/^\s*\>\s?/, "");
            };
            class_1.prototype.getLineNumber = function () {
                return ctx.getLineNumber();
            };
            return class_1;
        }(ParseContext)))();
        var stack = parse(next);
        return (0, blocks_1.makeBlock)(stack, __assign({ unbreakable: true, style: "block" }, getPendingProps()));
    }
    /** Parse an `\\include(...)` tag */
    function parseIncludeTag(indent, pattern, remainder) {
        ctx.shift();
        if (!pattern) {
            throw Error("Missing file name in \\\\include(...) tag");
        }
        return (0, transclude_1.parseFileRef)(pattern, remainder, ctx, indent, getPendingProps());
    }
    /** Parse given lines, as long as indented same or greater */
    function parseAny(indent) {
        var content = [];
        var start = ctx.getLineNumber();
        var _loop_1 = function () {
            // peek text and check indent
            var line = ctx.peek();
            var i = ctx.isAt(start) ? indent : line.match(/^\s*/)[0].length;
            var text = line.slice(i);
            if (i < indent && text)
                return { value: content };
            // parse text, asserting that the parser head advances
            ctx.validate(function () {
                if (!text)
                    ctx.shift();
                else if (/^\\\\\{/.test(text))
                    parseCustomProps(i);
                else if (text[0] === "#")
                    content.push(parseHeading(i));
                else if (/^\-{3,}\s*$/.test(text))
                    content.push(parseSeparator());
                else if (/^\-\s/.test(text))
                    content.push(parseList(i, /^\s*\-\s/));
                else if (/^\*\s/.test(text))
                    content.push(parseList(i, /^\s*\*\s/));
                else if (/^\d+\.\s/.test(text))
                    content.push(parseList(i, /^\s*\d+\.\s/));
                else if (/^\>\s/.test(text))
                    content.push(parseBlock(i));
                else if (/^\`\`\`/.test(text))
                    content.push(parsePre(i));
                else {
                    // check for tags, otherwise treat as paragraph
                    var tagMatch = text.match(/^\s*\\\\(\w+)(?:\(([^\)]+)\))?(.*)/);
                    var tag = tagMatch && tagMatch[1].toLowerCase();
                    switch (tag) {
                        case "include":
                        case "image":
                        case "img":
                            content.push.apply(content, parseIncludeTag(i, tagMatch[2], tagMatch[3]));
                            break;
                        case "pagebreak":
                            ctx.shift();
                            content.push({ stack: [], pageBreak: "after" });
                            break;
                        case "toc":
                            ctx.shift();
                            content.push(ctx.output.getTOCTable());
                            break;
                        default:
                            content.push(parseParagraph(i));
                    }
                }
            });
        };
        while (ctx.hasInput()) {
            var state_1 = _loop_1();
            if (typeof state_1 === "object")
                return state_1.value;
        }
        return content;
    }
    return parseAny(0);
}
/** Parse an entire markdown file and return a content array */
function parseMarkdownFile(fileName, output, defs) {
    var str = (0, fs_1.readFileSync)(fileName).toString();
    if (output.config.output.debug) {
        console.log("...parsing " + fileName);
    }
    // parse file using a new context structure
    var ctx = new ParseContext(fileName, output, defs);
    try {
        ctx.append(str);
        return parse(ctx);
    }
    catch (err) {
        throw {
            code: "PARSE_ERROR",
            message: err.message || String(err),
            line: ctx.getLineNumber(),
            fileName: fileName,
        };
    }
}
exports.parseMarkdownFile = parseMarkdownFile;
